import { of, interval } from 'rxjs';
import { delay, take } from 'rxjs/operators';
import { cold } from 'jasmine-marbles';
import { HttpErrorResponse, HttpResponse } from '@angular/common/http';
import { isNullOrUndefined, randomNumber, MockApiService } from '@yunzhi/ng-mock-api';
import { __awaiter } from 'tslib';

/**
 * 测试时用于模拟delay.
 */
class DelayHandlerTesting {
    constructor() {
    }
    /**
     * 发生网络错误
     * @param message 错误消息
     * @param subscriber 消息推送者
     */
    error(message, subscriber) {
        this.randomDelayCallback(() => {
            subscriber.error(new HttpErrorResponse({
                status: 0,
                error: message,
                statusText: 'network error'
            }));
            subscriber.complete();
        });
    }
    /**
     * 返回供测试用的观察者
     * 如果当前为测试过程中，则调用cold方法返回观察者将不出抛出异常。
     * 否则使用of方法返回观察者
     * @param data 返回的数据
     * @param subject 可供继续发送数据的数据源
     */
    next(data, subject) {
        this.randomDelayCallback(() => {
            isNullOrUndefined(data) ? subject.next(new HttpResponse()) : subject.next(new HttpResponse({ body: data }));
            subject.complete();
        });
    }
    /**
     * 随机延迟回调
     * @param callbackFn 回调函数
     */
    randomDelayCallback(callbackFn) {
        const delayCount = randomNumber() % 6;
        try {
            let interval = '';
            for (let i = 0; i < delayCount; i++) {
                interval += '---';
            }
            cold(interval + '(x|)', { x: undefined })
                .subscribe(() => {
                callbackFn();
            });
        }
        catch (e) {
            if (e.message === 'No test scheduler initialized') {
                of(null).pipe(delay(delayCount * delayCount * 100))
                    .subscribe(() => {
                    callbackFn();
                });
            }
            else {
                throw e;
            }
        }
    }
}

// 开发时请启用如下代码
// import {MockApiInterceptor} from '../../../src/lib/mock-api.interceptor';
// import {MockApiService} from '../../../src/lib/mock-api.service';
/**
 * 测试专用模拟API拦截器.
 */
class MockApiTestingInterceptor {
    /**
     * 启动时注册API
     * @param mockApis 模拟API
     */
    static forRoot(mockApis) {
        const mockApiService = MockApiService.getMockApiService(new DelayHandlerTesting());
        mockApiService.registerMockApis(mockApis);
        MockApiTestingInterceptor.mockApiService = mockApiService;
        return MockApiTestingInterceptor;
    }
    intercept(req, next) {
        return MockApiTestingInterceptor.mockApiService.request(req);
    }
}
/**
 * 此静态变量应该变到构造函数中初始化.
 * 区别：
 * 1. 属性初始化：其它文件import本文件时执行
 * 2. 构造函数：实例化时执行
 */
MockApiTestingInterceptor.mockApiService = null;

/**
 * 等待方法体中的函数返回true后，再返回promise
 * @param lastMethod 返回boolean值的函数
 * @param failureMessage 错误提示消息
 * @param timeout 超时时间
 */
const waitsFor = (lastMethod, failureMessage = '花费的时间过长，请检查判断条件', timeout = 2000) => __awaiter(void 0, void 0, void 0, function* () {
    let spentTime = 0;
    while (!lastMethod()) {
        if (spentTime > timeout) {
            throw new Error('花费的时间过长，请检查判断条件');
        }
        yield interval(25).pipe(take(1)).toPromise();
        spentTime += 25;
    }
    return Promise.resolve(true);
});
/**
 * 等待一会
 * @param timeout 中断时长
 */
const waits = (timeout = 25) => __awaiter(void 0, void 0, void 0, function* () {
    while (timeout > 0) {
        yield interval(25).pipe(take(1)).toPromise();
        timeout -= 25;
    }
    return Promise.resolve();
});

/*
 * Public API Surface of mock-http-client testing
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MockApiTestingInterceptor, waits, waitsFor };
//# sourceMappingURL=yunzhi-ng-mock-api-testing.js.map
