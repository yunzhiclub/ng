import { of, Observable } from 'rxjs';
import { delay } from 'rxjs/operators';
import { HttpErrorResponse, HttpResponse, HttpRequest, HttpResponseBase } from '@angular/common/http';

/**
 * 对字符串进行简单的加密
 * @param string 加密后的字符串
 */
function hash(sourceString) {
    let hashCode = 0;
    let i;
    let chr;
    for (i = 0; i < sourceString.length; i++) {
        chr = sourceString.charCodeAt(i);
        // tslint:disable-next-line:no-bitwise
        hashCode = ((hashCode << 5) - hashCode) + chr;
        // tslint:disable-next-line:no-bitwise
        hashCode |= 0; // Convert to 32bit integer
    }
    return hashCode;
}
const randomNumber = (range = 1000) => {
    return Math.floor(Math.random() * range);
};
/**
 * 转换为loading字样
 * @param target 目标字符串
 * @param suffix 后缀
 * @param length 长度
 * @example
 * '请稍候' => '请稍候.'
 * '请稍候.' => '请稍候..'
 * '请稍候..' => '请稍候...'
 * '请稍候...' => '请稍候'
 */
function convertToLoadingFormat(target, suffix = '.', length = 3) {
    const strings = target.split(suffix);
    if (strings.length <= length) {
        target += '.';
    }
    else {
        target = strings[0];
    }
    return target;
}
class Assert {
    /**
     * 断言是数组
     * @param value 断言的值
     * @param message 出错提示
     */
    static isArray(value, message) {
        if (!isNotNullOrUndefined(value) || !Array.isArray(value)) {
            throw new Error(message);
        }
    }
    /**
     * 断言被定义
     * undefined 异常
     * null 成功
     * other 成功
     * @param args 多参数
     */
    static isDefined(...args) {
        const message = this.validateArgs(args);
        args.forEach(value => {
            if (!isDefined(value)) {
                throw new Error(message);
            }
        });
    }
    static isObject(...args) {
        const message = this.validateArgs(args);
        args.forEach(arg => {
            const type = typeof arg;
            const isObject = type === 'function' || type === 'object' && !!arg;
            if (!isObject) {
                throw new Error(message);
            }
        });
    }
    /**
     * 断言输入的值为字符串
     * @param args 字符串1，字符串2...提示信息
     */
    static isString(...args) {
        const message = this.validateArgs(args);
        args.forEach(value => {
            if (typeof value !== 'string') {
                throw new Error(message);
            }
        });
    }
    static isNotNullOrUndefined(...args) {
        const message = this.validateArgs(args);
        args.forEach((value, index) => {
            if (!isNotNullOrUndefined(value)) {
                throw new Error(`${message}:${index}`);
            }
        });
    }
    /**
     * 校验参考并返回参数的最后一项做为message提示消息返回
     * @param args 多个参数
     */
    static validateArgs(args) {
        if (args.length < 2) {
            throw new Error('最少输入两个参数');
        }
        if (typeof (args[args.length - 1]) !== 'string') {
            throw new Error('最后一个参数必须为字符串');
        }
        const message = args.pop();
        return message;
    }
    static isUndefined(param) {
        if (typeof param !== 'undefined') {
            throw new Error('变量已定义');
        }
    }
    /**
     * 断言为null
     * null 成功
     * undefined 异常
     * other 异常
     * @param param 输入
     */
    static isNull(param) {
        if (typeof param === 'undefined' || param !== null) {
            throw new Error('变量非空');
        }
    }
    /**
     * 断言类型为number
     * @param args 最少输入两个参数，前面的参数为校验值，最后一个提示信息
     */
    static isNumber(...args) {
        const message = this.validateArgs(args);
        args.forEach(value => {
            if (typeof value !== 'number') {
                throw new Error(message);
            }
        });
    }
    static isTrue(...args) {
        const message = this.validateArgs(args);
        args.forEach(value => {
            if (value !== true) {
                throw new Error(message);
            }
        });
    }
}
/**
 * 是否不为null或undefined
 * undefined -> false
 * null -> false
 * other -> true
 * @param value 值
 */
function isNotNullOrUndefined(value) {
    return value !== undefined && value !== null;
}
/**
 * 为null或undefined
 * @param value 值
 */
function isNullOrUndefined(value) {
    return !isNotNullOrUndefined(value);
}
/**
 * 是否被定义
 * undefined -> false
 * other -> true
 * @param value 校验值
 */
function isDefined(value) {
    return value !== undefined;
}
function uniqueId() {
    return '_' + Math.random().toString(36).substr(2, 9);
}
// 解码
const decodeUnicode = (str) => {
    str = '\\u' + str;
    str = str.replace(/\\/g, '%');
    str = unescape(str);
    str = str.replace(/%/g, '\\');
    return str;
};
class Random {
    /**
     * 获取随机数据
     * @param width 位宽
     */
    static nextNumber(width = 32) {
        let range = 1;
        while (width > 0) {
            range = range * 2;
            width--;
        }
        return Math.floor(Math.random() * range);
    }
    /**
     * 获取随机字符串
     * @param prefix 返回字符串的前缀
     * @param length 字符串长度
     */
    static nextString(prefix = '', length = 4) {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return prefix + result;
    }
}
/*
* 获取取机的中文字符串
*/
const randomChineseString = (preString = '', length = 3) => {
    let name = '';
    for (let i = 0; i < length; i++) {
        let unicodeNum = '';
        unicodeNum = randomNumberByRange(0x4e00, 0x9fa5).toString(16);
        name += decodeUnicode(unicodeNum);
    }
    return preString + name;
};
/**
 * 获取指定范围内的随机数
 * @param min 最小值
 * @param max 最大值
 */
const randomNumberByRange = (min = 0, max = 1000) => {
    return Math.floor(Math.random() * (min - max) + max);
};
/**
 * 随机时间戳
 * @param day 随机生成的时间范围（天）
 * @param baseDate 生成时间范围基于某天
 * @sample
 * randomTimestamp(10, new Date(2020, 7, 12))
 * 返回：2020年7月12日前后10天的随机一天
 */
const randomTimestamp = (day = 7, baseDate = new Date()) => {
    const range = 1000 * 60 * 60 * 24 * day * 2;
    return baseDate.getTime() + randomNumber(range) - range / 2;
};
const randomBoolean = () => {
    return randomNumber(10) % 2 === 0;
};
const randomString = (prefix = '', length = 4) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return prefix + result;
};

/**
 * 延时处理器.
 */
class DelayHandler {
    constructor() {
    }
    /**
     * 发生错误时延时调用error方法
     * @param message 错误信息
     * @param subscriber 订阅者
     */
    error(message, subscriber) {
        this.randomDelayCallback(() => {
            subscriber.error(new HttpErrorResponse({
                status: 0,
                error: message,
                statusText: 'network error'
            }));
            subscriber.complete();
        });
    }
    /**
     * 使用随机的延时返回数据
     * @param data 数据
     * @param subscriber 订阅者
     */
    next(data, subscriber) {
        this.randomDelayCallback(() => {
            subscriber.next(new HttpResponse({ body: data }));
            subscriber.complete();
        });
    }
    randomDelayCallback(callbackFn) {
        of(null).pipe(delay(randomNumber() % 6 * 100)).subscribe(() => {
            callbackFn();
        });
    }
}

/**
 * 模拟API
 */
class MockApiService {
    /**
     * 循环调用从而完成所有的接口注册
     */
    constructor(delayHandler) {
        this.delayHandler = delayHandler;
        /**
         * 路由信息
         * Record<请求方法, Record<请求地址（正则表达式）, 回调函数<模拟返回的实体类型>>>
         */
        this.routers = {};
    }
    static getMockApiService(mockObservable) {
        return new MockApiService(mockObservable);
    }
    /**
     * 注册模拟接口
     * @param classes 接口类型
     */
    registerMockApis(classes) {
        classes.forEach(clazz => {
            const instance = new clazz();
            const injectors = instance.getInjectors();
            injectors.forEach(injector => {
                this.registerMockApi(injector.method, injector.url, injector.result);
            });
        });
    }
    /**
     * 注册模拟接口
     * @param method 请求方法
     * @param url 请求地址
     * @param handlerOrResult 获取数据源方法
     */
    registerMockApi(method, url, handlerOrResult) {
        if (method === null || method === undefined) {
            method = 'GET';
        }
        if (undefined === this.routers[method] || null === this.routers[method]) {
            this.routers[method] = {};
        }
        if (isNotNullOrUndefined(this.routers[method][url])) {
            throw Error(`在地址${url}已存在${method}的路由记录`);
        }
        this.routers[method][url] = handlerOrResult;
    }
    request(arg0, ...args) {
        // 初化始信息
        let url;
        let options;
        let method;
        // 根据请求参数类型,初始化请求基本信息
        if (arg0 instanceof HttpRequest) {
            method = arg0.method.toUpperCase();
            url = arg0.url;
            options = {
                body: arg0.body,
                headers: arg0.headers,
                reportProgress: arg0.reportProgress,
                observe: 'body',
                params: arg0.params,
                responseType: arg0.responseType,
                withCredentials: arg0.withCredentials
            };
        }
        else {
            method = arg0;
            url = args[0];
            options = args[1];
        }
        // 根据请求数据,查找注册的API
        const keys = [];
        let requestHandler = null;
        let urlMatches = undefined;
        const urlRecord = this.routers[method];
        for (const key in urlRecord) {
            if (urlRecord.hasOwnProperty(key)) {
                const reg = new RegExp(`^${key}$`);
                if (reg.test(url)) {
                    urlMatches = url.match(reg);
                    requestHandler = urlRecord[key];
                    keys.push(key);
                    if (keys.length > 1) {
                        const message = 'yzMockApi Error: conflict, matched multiple routes';
                        console.error(message, method, url, keys);
                        return new Observable(subscriber => {
                            this.delayHandler.error(message, subscriber);
                        });
                    }
                }
            }
        }
        // 未找到API则报错
        if (keys.length === 0) {
            return new Observable(subscriber => {
                const message = `yzMockApi Error: can't find mock result data: \n` +
                    `1. pls make sure the request's url '${url}' and method '${method}' is right. \n` +
                    `2. pls make sure your mockApi file has been added to the module HttpInterceptor.`;
                console.error(message);
                this.delayHandler.error(message, subscriber);
            });
        }
        // requestHandler可能是回调,也可能是返回值.在此做类型的判断.
        let result = null;
        if (typeof requestHandler === 'function') {
            requestHandler = requestHandler;
            result = requestHandler(urlMatches, options);
        }
        else {
            requestHandler = requestHandler;
            result = requestHandler;
        }
        // 按最终结果的类型分别返回
        if (result instanceof Observable) {
            return result;
        }
        else if (result instanceof HttpResponseBase) {
            return new Observable(ob => {
                ob.next(result);
                ob.complete();
            });
        }
        else {
            // 一般数据时加入延时
            return new Observable(observable1 => {
                this.delayHandler.next(result, observable1);
            });
        }
    }
}

/**
 * 模拟拦截器.
 */
class MockApiInterceptor {
    /**
     * 启动时注册API
     * @param mockApis 模拟API
     */
    static forRoot(mockApis) {
        const mockApiService = MockApiService.getMockApiService(new DelayHandler());
        mockApiService.registerMockApis(mockApis);
        MockApiInterceptor.mockApiService = mockApiService;
        return MockApiInterceptor;
    }
    intercept(req, next) {
        return MockApiInterceptor.mockApiService.request(req);
    }
}
/**
 * 此静态变量应该变到构造函数中初始化.
 * 区别：
 * 1. 属性初始化：其它文件import本文件时执行
 * 2. 构造函数：实例化时执行
 */
MockApiInterceptor.mockApiService = null;

/**
 * 此文中Benson对构造函数的重载回答的真好!
 * https://www.itranslater.com/qa/details/2109909368035607552
 */
class ApiInjector {
    constructor(obj = {}) {
        this.method = obj.method;
        this.url = obj.url;
        this.description = obj.description;
        this.result = obj.result;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ApiInjector, Assert, MockApiInterceptor, MockApiService, Random, convertToLoadingFormat, hash, isDefined, isNotNullOrUndefined, isNullOrUndefined, randomBoolean, randomChineseString, randomNumber, randomString, randomTimestamp, uniqueId };
//# sourceMappingURL=yunzhi-ng-mock-api.js.map
